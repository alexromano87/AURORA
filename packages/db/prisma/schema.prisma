// AURORA Database Schema
// PostgreSQL + TimescaleDB

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== IPS & Policy ====================

model IpsPolicy {
  id        String   @id @default(uuid())
  userId    String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  versions IpsPolicyVersion[]

  @@map("ips_policy")
}

model IpsPolicyVersion {
  id          String    @id @default(uuid())
  policyId    String
  version     String // Semantic version: 1.0.0
  config      Json // IPS JSON structure
  isActive    Boolean   @default(false)
  createdAt   DateTime  @default(now())
  activatedAt DateTime?

  policy IpsPolicy @relation(fields: [policyId], references: [id], onDelete: Cascade)

  @@unique([policyId, version])
  @@index([policyId, isActive])
  @@map("ips_policy_version")
}

// ==================== Instruments ====================

model Instrument {
  id       String   @id @default(uuid())
  isin     String?  @unique // Optional: allow null when ISIN is missing
  name     String
  ticker   String?
  currency String  @default("EUR")
  type     String // "ETF", "STOCK", "BOND", "CRYPTO", "CASH"
  category String? // "equity_global", "bond_government", etc.
  domicile String? // "IE", "LU", etc.
  provider String? // "iShares", "Vanguard", etc.
  isUcits  Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  etfMetrics     EtfMetrics?
  isinMapping    IsinMapping?
  transactions   Transaction[]
  positions      Position[]
  priceHistory   PriceHistory[]
  scoringResults EtfScoringResult[]

  @@index([isin])
  @@index([type, category])
  @@map("instrument")
}

model IsinMapping {
  id             String    @id @default(uuid())
  instrumentId   String    @unique @map("instrument_id")
  yahooTicker    String?
  exchange       String?
  verified       Boolean   @default(false)
  lastVerifiedAt DateTime?

  instrument Instrument @relation(fields: [instrumentId], references: [id], onDelete: Cascade)

  @@map("isin_mapping")
}

model EtfMetrics {
  id           String @id @default(uuid())
  instrumentId String @unique

  ter                Float?    // Total Expense Ratio (%)
  aum                Float?    // Assets Under Management (EUR)
  inceptionDate      DateTime?
  replicationMethod  String? // "Physical", "Synthetic"
  distributionPolicy String? // "Accumulating", "Distributing"

  trackingDifference Float? // vs benchmark (%)
  trackingError      Float? // volatility of TD

  avgDailyVolume Float? // Last 3 months
  avgSpread      Float? // Bid-ask spread (%)

  dataCompleteness Float?   // 0.0 - 1.0
  lastUpdated      DateTime @default(now())

  instrument Instrument @relation(fields: [instrumentId], references: [id], onDelete: Cascade)

  @@index([instrumentId])
  @@map("etf_metrics")
}

model PriceHistory {
  id           String   @id @default(uuid())
  instrumentId String
  date         DateTime @db.Date
  close        Float    // Prezzo in EUR (convertito se necessario)
  open         Float?
  high         Float?
  low          Float?
  volume       Float?

  // Prezzi originali nella valuta di origine (prima della conversione)
  originalClose    Float?  // Prezzo originale (null se gi√† in EUR)
  originalOpen     Float?
  originalHigh     Float?
  originalLow      Float?
  originalCurrency String? // Valuta originale (null se EUR)

  instrument Instrument @relation(fields: [instrumentId], references: [id], onDelete: Cascade)

  @@unique([instrumentId, date])
  @@index([instrumentId, date])
  @@map("price_history")
}

// ==================== Portfolio & Transactions ====================

model Portfolio {
  id     String @id @default(uuid())
  name   String
  type   String @default("paper") // "paper" | "real"
  userId String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  transactions Transaction[]
  positions    Position[]
  snapshots    PositionSnapshot[]
  proposals    Proposal[]
  alerts       Alert[]

  @@index([userId, type])
  @@map("portfolio")
}

model Transaction {
  id           String @id @default(uuid())
  portfolioId  String
  instrumentId String

  side      String // "BUY" | "SELL"
  quantity  Float
  priceEur  Float
  feeEur    Float  @default(0)
  totalEur  Float // quantity * price + fee

  executedAt DateTime @default(now())
  note       String?

  portfolio  Portfolio  @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
  instrument Instrument @relation(fields: [instrumentId], references: [id])

  @@index([portfolioId, executedAt])
  @@index([instrumentId])
  @@map("transaction")
}

model Position {
  id           String @id @default(uuid())
  portfolioId  String
  instrumentId String

  quantity   Float
  avgCostEur Float // Average purchase price

  updatedAt DateTime @updatedAt

  portfolio  Portfolio  @relation(fields: [portfolioId], references: [id], onDelete: Cascade)
  instrument Instrument @relation(fields: [instrumentId], references: [id])

  @@unique([portfolioId, instrumentId])
  @@index([portfolioId])
  @@map("position")
}

model PositionSnapshot {
  id            String   @id @default(uuid())
  portfolioId   String
  snapshotDate  DateTime @db.Date
  totalValueEur Float

  items Json // Array of {instrument_id, qty, price, value, weight, drift}

  createdAt DateTime @default(now())

  portfolio Portfolio @relation(fields: [portfolioId], references: [id], onDelete: Cascade)

  @@unique([portfolioId, snapshotDate])
  @@index([portfolioId, snapshotDate])
  @@map("position_snapshot")
}

// ==================== Proposals & Engine Runs ====================

model Proposal {
  id          String     @id @default(uuid())
  runId       String     @unique
  run         EngineRun  @relation(fields: [runId], references: [runId])
  portfolioId String

  type      String   // "ETF_SCORING" | "PORTFOLIO_PROPOSAL" | "MONTHLY_PAC"
  dataAsof  DateTime @db.Date

  tradeList Json // Array of {instrument_id, side, amount_eur}
  rationale Json // {targets, drift_snapshot, constraints_passed, ...}

  inputHash  String?
  outputHash String?

  status String @default("pending") // "pending" | "executed" | "rejected"

  createdAt  DateTime  @default(now())
  executedAt DateTime?

  portfolio Portfolio @relation(fields: [portfolioId], references: [id], onDelete: Cascade)

  @@index([portfolioId, dataAsof])
  @@index([runId])
  @@map("proposal")
}

model EngineRun {
  id     String @id @default(uuid())
  runId  String @unique
  userId String

  type   String @default("queued") // "queued" | "running" | "completed" | "failed"
  status String // "ETF_SCORING" | "MONTHLY_PAC" | etc.

  inputParams Json
  result      Json?
  error       String?

  startedAt   DateTime?
  completedAt DateTime?
  durationMs  Int?

  createdAt DateTime @default(now())

  scoringResults EtfScoringResult[]
  pacProposals   Proposal[]

  @@index([runId])
  @@index([userId, type, status])
  @@map("engine_run")
}

// ==================== Alerts ====================

model Alert {
  id          String     @id @default(uuid())
  portfolioId String?
  portfolio   Portfolio? @relation(fields: [portfolioId], references: [id])

  priority String // "high" | "medium" | "low"
  type     String // "drift_breach" | "concentration" | etc.
  title    String
  message  String
  data     Json?

  acknowledged   Boolean   @default(false)
  acknowledgedAt DateTime?

  createdAt DateTime @default(now())

  @@index([portfolioId, acknowledged])
  @@index([priority, acknowledged])
  @@map("alert")
}

// ==================== ETF Scoring Results ====================

model EtfScoringResult {
  id           String     @id @default(uuid())
  runId        String
  run          EngineRun  @relation(fields: [runId], references: [runId])
  instrumentId String
  instrument   Instrument @relation(fields: [instrumentId], references: [id])
  bucket       String     // "equity_global", etc.

  score     Float
  breakdown Json // {costs: X, tracking: Y, ...}
  redFlags  Json // Array of strings

  dataAsof  DateTime @db.Date
  createdAt DateTime @default(now())

  @@index([runId])
  @@index([bucket, score])
  @@map("etf_scoring_result")
}

// ==================== Personal Finance Management ====================

model BankAccount {
  id             String   @id @default(uuid())
  userId         String
  name           String                          // "Conto Principale", "Carta Visa"
  type           String   @default("CHECKING")   // CHECKING, SAVINGS, CREDIT_CARD, CASH
  currency       String   @default("EUR")        // EUR, USD, GBP, CHF, etc.
  initialBalance Float    @default(0)
  currentBalance Float    @default(0)            // Calcolato dalle transazioni
  isActive       Boolean  @default(true)
  color          String?                         // Hex color per UI
  icon           String?                         // Lucide icon name
  linkedPortfolioId String?                      // Link opzionale a portfolio investimenti

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  transactions    PersonalTransaction[] @relation("AccountTransactions")
  transfersFrom   PersonalTransaction[] @relation("TransferFrom")
  transfersTo     PersonalTransaction[] @relation("TransferTo")
  balanceHistory  AccountBalanceHistory[]

  @@index([userId, isActive])
  @@map("bank_account")
}

model AccountBalanceHistory {
  id        String   @id @default(uuid())
  accountId String
  date      DateTime @db.Date
  balance   Float

  account BankAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([accountId, date])
  @@index([accountId, date])
  @@map("account_balance_history")
}

model ExpenseCategory {
  id        String   @id @default(uuid())
  userId    String?                              // null = sistema, non-null = custom utente
  name      String                               // Chiave univoca (es: "groceries")
  nameIt    String                               // Nome italiano (es: "Alimentari")
  icon      String                               // Lucide icon name
  color     String                               // Hex color
  parentId  String?                              // Per sottocategorie
  isSystem  Boolean  @default(false)
  isActive  Boolean  @default(true)
  sortOrder Int      @default(0)

  parent       ExpenseCategory?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children     ExpenseCategory[] @relation("CategoryHierarchy")
  transactions PersonalTransaction[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, name])
  @@index([userId, isActive])
  @@map("expense_category")
}

model PersonalTransaction {
  id          String   @id @default(uuid())
  userId      String
  accountId   String
  type        String                             // INCOME, EXPENSE, TRANSFER

  amount      Float                              // Sempre positivo
  currency    String   @default("EUR")
  amountEur   Float                              // Convertito in EUR per aggregazioni

  categoryId  String?
  merchant    String?                            // "Esselunga", "Amazon"
  description String?
  note        String?

  // Per trasferimenti
  transferToAccountId   String?
  transferFromAccountId String?
  linkedTransferId      String?                  // Collega le due parti di un transfer

  // Metadata categorizzazione LLM
  llmCategorized       Boolean @default(false)
  llmConfidence        Float?                    // 0.0 - 1.0
  llmSuggestedCategory String?                   // Suggerimento originale LLM

  // Metadata import
  importBatchId String?
  importSource  String?                          // "csv_import", "manual"
  externalId    String?                          // ID banca per deduplicazione

  transactionDate DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  account      BankAccount      @relation("AccountTransactions", fields: [accountId], references: [id], onDelete: Cascade)
  category     ExpenseCategory? @relation(fields: [categoryId], references: [id])
  transferTo   BankAccount?     @relation("TransferTo", fields: [transferToAccountId], references: [id])
  transferFrom BankAccount?     @relation("TransferFrom", fields: [transferFromAccountId], references: [id])

  @@index([userId, transactionDate])
  @@index([accountId, transactionDate])
  @@index([categoryId])
  @@index([importBatchId])
  @@map("personal_transaction")
}

model ImportBatch {
  id        String   @id @default(uuid())
  userId    String
  accountId String
  filename  String
  source    String                               // "csv", "excel"
  status    String   @default("pending")         // pending, processing, completed, failed

  totalRows     Int @default(0)
  processedRows Int @default(0)
  importedRows  Int @default(0)
  duplicateRows Int @default(0)
  errorRows     Int @default(0)

  errors  Json?
  mapping Json?

  createdAt   DateTime  @default(now())
  completedAt DateTime?

  @@index([userId, createdAt])
  @@map("import_batch")
}

model LlmAnalysisCache {
  id        String   @id @default(uuid())
  userId    String
  type      String                               // categorization, spending_analysis, purchase_advice
  inputHash String
  prompt    String   @db.Text
  response  Json
  tokensUsed Int?

  createdAt DateTime @default(now())
  expiresAt DateTime

  @@unique([userId, type, inputHash])
  @@index([expiresAt])
  @@map("llm_analysis_cache")
}

model SpendingAlert {
  id       String   @id @default(uuid())
  userId   String
  type     String                                // anomaly, budget_exceeded, unusual_merchant
  severity String                                // info, warning, critical
  title    String
  message  String
  data     Json?

  acknowledged   Boolean   @default(false)
  acknowledgedAt DateTime?

  createdAt DateTime @default(now())

  @@index([userId, acknowledged])
  @@map("spending_alert")
}
